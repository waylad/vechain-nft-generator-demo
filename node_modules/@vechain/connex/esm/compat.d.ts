/// <reference types="@vechain/connex-types" />
/// <reference types="@vechain/connex-framework/dist/driver-interface" />
/** ports connex v1 to connex v2 */
export declare function compat1(connex1: Connex1): Connex;
declare interface Connex1 {
    readonly version: string;
    readonly thor: Connex1.Thor;
    readonly vendor: Connex1.Vendor;
}
declare namespace Connex1 {
    interface Thor {
        readonly genesis: Thor.Block;
        readonly status: Thor.Status;
        ticker(): Thor.Ticker;
        account(addr: string): Thor.AccountVisitor;
        block(revision?: string | number): Thor.BlockVisitor;
        transaction(id: string): Thor.TransactionVisitor;
        filter<T extends 'event' | 'transfer'>(kind: T): Thor.Filter<T>;
        explain(): Thor.Explainer;
    }
    namespace Thor {
        interface Ticker {
            next(): Promise<Status['head']>;
        }
        interface AccountVisitor {
            readonly address: string;
            get(): Promise<Account>;
            getCode(): Promise<Code>;
            getStorage(key: string): Promise<Storage>;
            method(abi: object): Method;
            event(abi: object): EventVisitor;
        }
        interface Method {
            value(val: string | number): this;
            caller(addr: string): this;
            gas(gas: number): this;
            gasPrice(gp: string | number): this;
            cache(ties: string[]): this;
            asClause(...args: any[]): Clause;
            call(...args: any[]): Promise<VMOutput>;
        }
        interface EventVisitor {
            asCriteria(indexed: object): Event.Criteria;
            filter(indexedSet: object[]): Filter<'event'>;
        }
        interface BlockVisitor {
            readonly revision: string | number;
            get(): Promise<Block | null>;
        }
        interface TransactionVisitor {
            readonly id: string;
            allowPending(): this;
            get(): Promise<Transaction | null>;
            getReceipt(): Promise<Receipt | null>;
        }
        interface Filter<T extends 'event' | 'transfer'> {
            criteria(set: Filter.Criteria<T>[]): this;
            range(range: Filter.Range): this;
            order(order: 'asc' | 'desc'): this;
            apply(offset: number, limit: number): Promise<Thor.Filter.Result<T>>;
        }
        interface Explainer {
            caller(addr: string): this;
            gas(gas: number): this;
            gasPrice(gp: string | number): this;
            execute(clauses: Clause[]): Promise<VMOutput[]>;
        }
        type Status = {
            progress: number;
            head: {
                id: string;
                number: number;
                timestamp: number;
                parentID: string;
                txsFeatures?: number;
            };
        };
        type Account = {
            balance: string;
            energy: string;
            hasCode: boolean;
        };
        type Storage = {
            value: string;
        };
        type Code = {
            code: string;
        };
        type Block = {
            id: string;
            number: number;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures?: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            transactions: string[];
            isTrunk: boolean;
        };
        type Clause = {
            to: string | null;
            value: string | number;
            data?: string;
        };
        namespace Transaction {
            type Meta = {
                blockID: string;
                blockNumber: number;
                blockTimestamp: number;
            };
        }
        type Transaction = {
            id: string;
            chainTag: number;
            blockRef: string;
            expiration: number;
            clauses: Array<{
                to: string | null;
                value: string;
                data: string;
            }>;
            gasPriceCoef: number;
            gas: number;
            origin: string;
            delegator?: string | null;
            nonce: string;
            dependsOn: string | null;
            size: number;
            meta: Transaction.Meta;
        };
        type Receipt = {
            gasUsed: number;
            gasPayer: string;
            paid: string;
            reward: string;
            reverted: boolean;
            outputs: {
                contractAddress: string | null;
                events: Event[];
                transfers: Transfer[];
            }[];
            meta: Receipt.Meta;
        };
        namespace Receipt {
            type Meta = Transaction.Meta & {
                txID: string;
                txOrigin: string;
            };
        }
        type Event = {
            address: string;
            topics: string[];
            data: string;
            meta?: LogMeta;
            decoded?: Decoded;
        };
        namespace Event {
            type Criteria = {
                address?: string;
                topic0?: string;
                topic1?: string;
                topic2?: string;
                topic3?: string;
                topic4?: string;
            };
        }
        type Transfer = {
            sender: string;
            recipient: string;
            amount: string;
            meta?: LogMeta;
        };
        namespace Transfer {
            type Criteria = {
                txOrigin?: string;
                sender?: string;
                recipient?: string;
            };
        }
        type LogMeta = Receipt.Meta & {
            clauseIndex: number;
        };
        namespace Filter {
            type Criteria<T extends 'event' | 'transfer'> = T extends 'event' ? Event.Criteria : T extends 'transfer' ? Transfer.Criteria : never;
            type Range = {
                unit: 'block' | 'time';
                from: number;
                to: number;
            };
            type Result<T extends 'event' | 'transfer'> = Array<T extends 'event' ? Event : T extends 'transfer' ? Transfer : never>;
        }
        type VMOutput = {
            data: string;
            vmError: string;
            gasUsed: number;
            reverted: boolean;
            events: Event[];
            transfers: Transfer[];
            decoded?: Decoded & {
                revertReason?: string;
            };
        };
        type Decoded = {
            [name: string]: any;
        } & {
            [index: number]: any;
        };
    }
    interface Vendor {
        sign<T extends 'tx' | 'cert'>(kind: T): Vendor.SigningService<T>;
        owned(addr: string): Promise<boolean>;
    }
    namespace Vendor {
        interface TxSigningService {
            signer(addr: string): this;
            gas(gas: number): this;
            dependsOn(txid: string): this;
            link(url: string): this;
            comment(text: string): this;
            delegate(handler: DelegationHandler): this;
            request(msg: TxMessage): Promise<TxResponse>;
        }
        interface CertSigningService {
            signer(addr: string): this;
            link(url: string): this;
            request(msg: CertMessage): Promise<CertResponse>;
        }
        type SigningService<T extends 'tx' | 'cert'> = T extends 'tx' ? TxSigningService : T extends 'cert' ? CertSigningService : never;
        type TxMessage = Array<Thor.Clause & {
            comment?: string;
            abi?: object;
        }>;
        type CertMessage = {
            purpose: 'identification' | 'agreement';
            payload: {
                type: 'text';
                content: string;
            };
        };
        type TxResponse = {
            txid: string;
            signer: string;
        };
        type CertResponse = {
            annex: {
                domain: string;
                timestamp: number;
                signer: string;
            };
            signature: string;
        };
        type DelegationHandler = (unsignedTx: {
            raw: string;
            origin: string;
        }) => Promise<{
            signature: string;
        }>;
    }
    type ErrorType = 'BadParameter' | 'Rejected';
}
export {};
